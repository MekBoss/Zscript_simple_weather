//thinker responsible for spawning weather actors
class thundercloud : thinker
{
    //position on a map around which thinker should spawn snow/rain
    private vector2 map_spot;
    //distance to check around map point is player inside
    //and to determine how fasr away from map spot weather should have spawns
    private vector2 check_distances;
    //used for checking is percipitation spawned inside sky sector
    private array<line> closest_lines;

    private sector_cyclon origin_thinker;
    private double min_z_height;
    private double player_camera_height;
    private uint timer;
    private int attached_sector;

    thundercloud init(vector2 v, sector_cyclon it, vector2 d, int sec_id)
    {
        map_spot = v;
        origin_thinker = it;
        check_distances = d;
        min_z_height = interval_between_points * 3;
        attached_sector = sec_id;

        return self;
    }

    //fills volume  of sector near spawn point with percipitations
    private void fill_volume()
    {
        for(uint i = 0; i < 30; i++)
        {
            vector3 v =
            (
                map_spot.x + frandom(-check_distances.x, check_distances.x),
                map_spot.y + frandom(-check_distances.y, check_distances.y),
                0
            );

            double ceil_hei = level.sectors[attached_sector].ceilingplane.ZatPoint(v.xy);
            double floor_hei = level.sectors[attached_sector].ceilingplane.ZatPoint(v.xy);

            v.z = frandom(floor_hei, ceil_hei);
            sector_cyclon(origin_thinker).raining_men(v);
        }
    }

    //check is any player near this weather spawning point
    private bool player_nearby()
    {
        bool is_looking = false;
        for (int i = 0; i < MAXPLAYERS; i++)
        {
            PlayerInfo p = players[i];
            
            if (p != null && p.camera != null)
            {
                if(abs(p.camera.pos.x - map_spot.x) <= check_distances.x * 2 && abs(p.camera.pos.y - map_spot.y) <= check_distances.y * 2)
                {
                    player_camera_height = p.camera.pos.z;
                    is_looking = true;
                    break;
                }
            }
        }
        return is_looking;
    }

    override void tick()
    {
        //if level is frozen return to not spawn >90000 weather actors
        if(!CWE_weather || globalfreeze) return;

        timer ++;
        
        if(timer >= CWE_intensity)
        {
            timer = 0;
            if(player_nearby() )
            {
                vector3 v =
                (
                    map_spot.x + frandom(-check_distances.x, check_distances.x),
                    map_spot.y + frandom(-check_distances.y, check_distances.y),
                    0
                );

                double cam_pos = player_camera_height + min_z_height;
                double ceil_hei = level.sectors[attached_sector].ceilingplane.ZatPoint(v.xy);

                v.z = cam_pos < ceil_hei ? cam_pos : ceil_hei;
                sector_cyclon(origin_thinker).raining_men(v);
            }
        }
    }

}