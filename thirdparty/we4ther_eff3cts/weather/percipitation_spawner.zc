//thinker responsible for spawning weather actors
class thundercloud : thinker
{
    //position on a map around which thinker should spawn snow/rain
    private vector2 map_spot;
    //distance to check around map point is player inside
    //and to determine how fasr away from map spot weather should have spawns
    private vector2 check_distances;
    //used for checking is percipitation spawned inside sky sector
    private array<int> closest_lines;

    private sector_cyclon origin_thinker;
    private double min_z_height;
    private double player_camera_height;
    private uint timer;
    private int main_sector;

    static thundercloud new_thundercloud(vector2 vec, sector_cyclon it, vector2 dist, in array<int> cl)
    {
        thundercloud tc = thundercloud(new("thundercloud") );

        tc.map_spot = vec;
        tc.origin_thinker = it;
        tc.check_distances = dist;
        tc.min_z_height = interval_between_points * 3;
        tc.closest_lines.move(cl);
        int l; double d;
        [l, d] = tc.find_closest_line((vec, 0));
        if(d > dist.x && d > dist.y)
        {
            //too far away from sky sector
            tc.destroy();
            return null;
        }

        return tc;
    }

    //fills volume  of sector near spawn point with percipitations
    private void fill_volume()
    {
        for(uint i = 0; i < 30; i++)
        {
            vector3 v =
            (
                map_spot.x + frandom(-check_distances.x, check_distances.x),
                map_spot.y + frandom(-check_distances.y, check_distances.y),
                0
            );

            double ceil_hei = level.sectors[main_sector].ceilingplane.ZatPoint(v.xy);
            double floor_hei = level.sectors[main_sector].floorplane.ZatPoint(v.xy);

            v.z = frandom(floor_hei, ceil_hei);
            sector_cyclon(origin_thinker).raining_men(v);
        }
    }

    //check is any player near this weather spawning point
    private bool player_nearby()
    {
        bool is_looking = false;
        for (int i = 0; i < MAXPLAYERS; i++)
        {
            PlayerInfo p = players[i];
            
            if (p != null && p.camera != null)
            {
                if(abs(p.camera.pos.x - map_spot.x) <= check_distances.x * 2 && abs(p.camera.pos.y - map_spot.y) <= check_distances.y * 2)
                {
                    player_camera_height = p.camera.pos.z;
                    is_looking = true;
                    break;
                }
            }
        }
        return is_looking;
    }

    private int, double find_closest_line(vector3 pos)
    {
        double dist = double.infinity;
        int closest = -1;
        for(uint i = 0; i < closest_lines.size(); i++)
        {
            double line_dist_sqrd = weather_math.line_point_distance(pos, (level.lines[closest_lines[i]].v1.p, 0), (level.lines[closest_lines[i]].delta, 0), true);
            if(line_dist_sqrd < dist)
            {
                dist = line_dist_sqrd;
                closest = closest_lines[i];
            }
        }
        return closest, dist;
    }

    override void tick()
    {
        //if level is frozen return to not spawn >90000 weather actors
        if(!CWE_weather || globalfreeze) return;

        timer ++;
        
        if(timer >= CWE_intensity)
        {
            timer = 0;
            if(player_nearby() )
            {
                vector3 v =
                (
                    map_spot.x + frandom(-check_distances.x, check_distances.x),
                    map_spot.y + frandom(-check_distances.y, check_distances.y),
                    0
                );

                int near_line = find_closest_line(v);



                double cam_pos = player_camera_height + min_z_height;
                double ceil_hei = level.sectors[main_sector].ceilingplane.ZatPoint(v.xy);

                v.z = cam_pos < ceil_hei ? cam_pos : ceil_hei;
                sector_cyclon(origin_thinker).raining_men(v);
            }
        }
    }

}