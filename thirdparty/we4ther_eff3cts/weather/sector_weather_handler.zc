class sector_cyclon : thinker
{
    //pointer to main event which create it and have array of all weather actors
    private weather_event god_of_weather;
    //all sectors attached to it
    private array<sector> attached_sectors;
    //bbox pojection on x y axis
    private vector2 projection_x, projection_y;
    //same as bbox, but already in 2d vector form
    private vector2 bounds_vertice_1, bounds_vertice_2, bounds_vertice_3, bounds_vertice_4;
    //technical value to prevent abusing of public init function
    private uint time;

    //state of a sector group
    private cyclon_state_enum cyclon_state;
    //all weather spawnpoints
    private array<thundercloud> thunder_front;

    /*
    compare
        &
    unset
        &= ~
    set
        |=
    */

    //init function / constructor
    sector_cyclon twist_the_cyclone(in out array<sector> s, vector2 first, vector2 second, weather_event it)
    {
        if(time == 0)
        {
            attached_sectors.move(s);
            god_of_weather = it;
            projection_x = first;
            projection_y = second;

            update_bbox_vertices(projection_x, projection_y);
            sector_thunderclouds();
            
            time = level.totaltime;

            vector2 sector_center = ( (projection_x.x + projection_x.y, projection_y.x + projection_y.y) / 2 );

            if(CWE_weather_type == CWE_RAIN)
                for(int i = 0; i < s.size(); i++)
                    start_sound_sequence(s[i]);
        }
        return self;
    }

    //fill all sector group with weather spawn points
    private void sector_thunderclouds()
    {
        double p_dist = interval_between_points * 2;

        double x_length, y_length, x_delta, y_delta;
        int _x_, _y_;
        uint i = 0;
        //getting length of a sector along each axis
        x_length = projection_x.y - projection_x.y;
        y_length = projection_y.y - projection_y.y;

        x_delta = x_length / p_dist;
        y_delta = y_length / p_dist;
    
        _x_ = int(x_delta);
        _y_ = int(y_delta);

        if(abs(_x_) > 0)
            x_delta = abs( ( ( (x_delta - _x_) / _x_) * p_dist ) );
        if(abs(_y_) > 0)
            y_delta = abs( ( ( (y_delta - _y_) / _y_) * p_dist ) );

        x_delta += p_dist;
        y_delta += p_dist;

        double x_min = projection_x.x + interval_between_points;
        double y_min = projection_y.x + interval_between_points;

        for(double xx = x_min; xx < (projection_x.y + x_delta); xx += x_delta)
        {
            for(double yy = y_min; yy < (projection_y.y + y_delta); yy += y_delta)
            {
                thundercloud mp = thundercloud(new("thundercloud") ).init( (xx, yy), self, (x_delta, y_delta) );
                if(mp)
                    thunder_front.push(mp);
            }

            //precautionary measures
            i++;
            if(i > 10000000)
                break;
        }
    }

    //technical method used in initialization inside event, return first attached sector
    sector get_original_sector() const
    {
        return attached_sectors[0];
    }

    //same as above, but return all attached sectors
    void get_sectors(out array<sector> it) const
    {
        it.copy(attached_sectors);
    }

    //obvious from name
    vector2, vector2 get_sector_bounds() const
    {
        return projection_x, projection_y;
    }
    //state of a cyclon thinker
    uint get_state() const
    {
        return cyclon_state;
    }
    protected void set_state(uint b)
    {
        cyclon_state |= b;
    }

    //update stored bbox using new set of data
    private void update_bbox_vertices(vector2 x_x, vector2 y_y)
    {
        //order dont matter
        bounds_vertice_1 = (x_x.x, y_y.x);
        bounds_vertice_2 = (x_x.x, y_y.y);
        bounds_vertice_3 = (x_x.y, y_y.x);
        bounds_vertice_4 = (x_x.y, y_y.y);
        /*
        actor.spawn("armorbonus", pos:(bounds_vertice_1, 0) );
        actor.spawn("armorbonus", pos:(bounds_vertice_2, 0) );
        actor.spawn("armorbonus", pos:(bounds_vertice_3, 0) );
        actor.spawn("armorbonus", pos:(bounds_vertice_4, 0) );
        */
    }

    //technical stuff for initialization and/or merging two thinkers together
    void merge_with(sector_cyclon with, weather_event caller)
    {
        if(caller && with && caller == god_of_weather)
        {
            vector2 proj_x, proj_y;
            [proj_x, proj_y] = with.get_sector_bounds();

            with.get_sectors(attached_sectors);

            //again, because vectors arrys in zscript is just a dream 
            if(proj_x.x < projection_x.x)
                projection_x.x = proj_x.x;
            if(proj_x.y > projection_x.y)
                projection_x.y = proj_x.y;

            if(proj_y.x < projection_y.x)
                projection_y.x = proj_y.x;
            if(proj_y.y > projection_y.y)
                projection_y.y = proj_y.y;

            update_bbox_vertices(projection_x, projection_y);
            thunder_front.copy(with.thunder_front);
        }
    }


    //МУЖЦИКИЙ ДОЖДЬ АЛЛИЛУЯ
    //АЛИЛУЯ ДОЖДЬ ИЗ МУЖИКОВ
    weather_actor raining_men(vector3 v)
    {
        if(god_of_weather)
        {
            weather_actor wa = weather_event(god_of_weather).find_droplet();
            weather_actor(wa).set_weather_type(CWE_weather_type);
            wa.setorigin(v, false);
        }
        return null;
    }

    //deconstructor
    override void OnDestroy()
    {
        for(uint i = 0; i < thunder_front.size(); i++)
            thunder_front[i].destroy();

        super.ondestroy();
    }

    //check is player near/inside sector group bbox
    private bool inside_sector_bbox(actor a)
    {
        if(!a)
            return false;

        double x_len, y_len;

        x_len = (projection_x.y - projection_x.x) / 2;
        y_len = (projection_y.y - projection_y.x) / 2;
        
        if( a.pos.x > projection_x.x - x_len &&
            a.pos.x < projection_x.y + x_len &&
            a.pos.y > projection_y.x - y_len &&
            a.pos.y < projection_y.y + y_len )
            return true; 

        return false;
    }

    //next functions apply more specific effects on specific weather
    private void check_for_ashes()
    {
        if(CWE_weather_type == CWE_ASH && !(cyclon_state & CSE_ASHED) )
        {
            cyclon_state |= CSE_ASHED;

            for(uint i = 0; i < attached_sectors.size(); i++)
            {
                attached_sectors[i].SetFade(color("C9C9C9") );
            }
        }

        if(CWE_weather_type != CWE_ASH && (cyclon_state & CSE_ASHED) )
        {
            cyclon_state &= ~CSE_ASHED;

            for(uint i = 0; i < attached_sectors.size(); i++)
            {
                attached_sectors[i].SetFade(color("000000") );
            }
        }
    }

    private void check_for_snow()
    {
        if(CWE_weather_type == CWE_SNOW && !(cyclon_state & CSE_SNOWY) )
        {
            cyclon_state |= CSE_SNOWY;

            for(uint i = 0; i < attached_sectors.size(); i++)
            {
                attached_sectors[i].SetFade(color("f0f0f0") );
            }
        }

        if(CWE_weather_type != CWE_SNOW && (cyclon_state & CSE_SNOWY) )
        {
            cyclon_state &= ~CSE_SNOWY;

            for(uint i = 0; i < attached_sectors.size(); i++)
            {
                attached_sectors[i].SetFade(color("000000") );
            }
        }
    }

    private void check_for_rain()
    {
        if(CWE_weather_type == CWE_RAIN && !(cyclon_state & CSE_RAINY) )
        {
            cyclon_state |= CSE_RAINY;

            for(uint i = 0; i < attached_sectors.size(); i++)
            {
                attached_sectors[i].SetFade(color("b5b5ff") );
            }
        }

        if(CWE_weather_type != CWE_RAIN && (cyclon_state & CSE_RAINY) )
        {
            cyclon_state &= ~CSE_RAINY;

            for(uint i = 0; i < attached_sectors.size(); i++)
            {
                attached_sectors[i].SetFade(color("000000") );
            }
        }
    }

    //attach specific sound to sector and return it channel
    private int start_sound_sequence(sector s, int type = -1)
    {
        int sound_chann = -1;
        for(uint i = 0; i < 64; i++)
        {
            if(!s.CheckSoundSequence(i) )
            {
                if(type == -1)
                {
                    s.StartSoundSequence(i, "rain_sequence", 1);
                    sound_chann = i;
                    break;
                }

                else
                {
                    string tt = string.format("thunder_ambient_", type);
                    s.StartSoundSequence(i, tt, 1);
                    sound_chann = i;
                    break;
                }
            }
        }

        return sound_chann;
    }


    void thunder_sound(eventhandler caller, int lighting_sound = 1)
    {
        if(caller != god_of_weather)
            return;
                
        for(uint i = 0; i < attached_sectors.size(); i++)
            start_sound_sequence(attached_sectors[i], lighting_sound);
    }

    //bright flash from lighting
    //happens before thunder sound
    void lighting_flash(eventhandler caller)
    {
        if(caller != god_of_weather)
            return;

        for(int i = 0; i < MAXPLAYERS; i++)
        {
            PlayerInfo p = players[i];
            
            if(inside_sector_bbox(p.mo) )
            {
                p.mo.a_setblend("FF, FF, FF", 1, 10);
            }
        }
    }

    //tic-tac, tic-tac, tic-tac.....
    override void tick()
    {
        if(!CWE_weather || globalfreeze) return;

        check_for_ashes();
        check_for_snow();
    }

}