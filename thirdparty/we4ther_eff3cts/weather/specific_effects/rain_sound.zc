//handler of rain sound
class rain_sound_speaker : base_weather_speaker
{
    private playerinfo player_target;
    private sector_cyclon group_affiliation;
    private textureid sky_texture;
    private vector2 group_center;
    //"attach" specifc rain sound speaker to specific player
    void attach_to_player(playerinfo i, sector_cyclon g, vector2 v)
    {
        player_target = i;
        group_affiliation = g;
        sky_texture = TexMan.checkForTexture("F_SKY1", TexMan.Type_Any);
        group_center = v;
    }
    //precache sound
    override void MarkPrecacheSounds()
    {
        MarkSound("rain_sound");
    }
    //simplify vector to almost unit but much cheaper/faster
    private vector3 almost_unit_vector(vector3 v)
    {
        if(v == (0, 0, 0) )
            return v;//0 = 0, obvious

        if(v != v)
            return (0, 0, 0);//case with NaN or infinity

        double divv = 1;//division by zero prevented

        if(abs(v.x) >= abs(v.y) && abs(v.x) >= abs(v.z) )
            divv = abs(v.x);
        if(abs(v.y) >= abs(v.x) && abs(v.y) >= abs(v.z) )
            divv = abs(v.y);
        if(abs(v.z) >= abs(v.y) && abs(v.z) >= abs(v.x) )
            divv = abs(v.z);

        v /= divv;

        return v;
    }
    //checks is rain speaker in its group sectors or no
    private bool is_own_sector_group(sector s)
    {
        if(group_affiliation)
        {
            return sector_cyclon(group_affiliation).sector_from_group(s);
        }
        return false;
    }

    states
    {
        spawn:
            bon2 a 1 nodelay
            {
                //console.printf("pos %f %f %f", pos.x, pos.y, pos.z);
                if(!CWE_rain_sound)
                {
                    //console.printf("cvar false");
                    return;
                }

                a_playsound("rain_sound", CHAN_BODY|CHAN_NOSTOP , 1, true);

                if(!player_target)
                {
                    //console.printf("no player");
                    a_stopsound(CHAN_BODY);
                    destroy();
                    return;            
                }


                //without it gzdoom throw error
                //reason zscript compiler cant work with "stored" playerinfo pointer in the same way as with "free"
                PlayerInfo p = player_target;

                vector3 move_dir = p.camera.pos - pos + (0, 0, p.camera.height / 2);
                //portal aware way
                //level.vec3diff(pos, p.camera.pos);
                //but current way much cheaper/faster
                if(p.camera.cursector.getTexture(Sector.ceiling) == sky_texture )
                {
                    if(move_dir dot move_dir < 50 * 50 || is_own_sector_group(p.camera.cursector) )
                    {
                        setorigin(p.camera.pos, false);
                        return;
                    }
                }

                move_dir = almost_unit_vector(move_dir);

                move_dir *= 10;

                vector3 old_position = pos;

                setorigin(pos + move_dir, false);

                if(! (cursector.getTexture(Sector.ceiling) == TexMan.checkForTexture("F_SKY1", TexMan.Type_Any) ) )
                {
                    //to prevent stucking in walls move it backward if it stuck
                    setorigin(old_position + (almost_unit_vector( (group_center,0) - old_position) * 10), false);
                }
            }
        loop;
    }

}