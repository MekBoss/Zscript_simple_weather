const interval_between_points = 150;

class sector_cyclon : thinker
{
//pointer to main event which create it and have array of all weather actors
private weather_event god_of_weather;
//all sectors attached to it
private array<sector> attached_sectors;
//bbox pojection on x y axis
private vector2 projection_x, projection_y;
//same as bbox, but already in 2d vector form
private vector2 bounds_vertice_1, bounds_vertice_2, bounds_vertice_3, bounds_vertice_4;
//technical value to prevent abusing of public init function
private uint time;

//state of a sector group
private cyclon_state_enum cyclon_state;
//all weather spawnpoints
private array<thundercloud> thunder_front;
//speaker for thunder sound
private actor weather_sound;
//array of all speakers assigned to specific player
private array<actor> rain_speakers_per_player;

enum cyclon_state_enum
{
    CSE_NOTHING = 0,
    CSE_ASHED = 1,
    CSE_SNOWY = 1 << 1,
    CSE_RAINY = 1 << 2
};
/*
compare
    &
unset
    &= ~
set
    |=
 */

//init function / constructor
sector_cyclon twist_the_cyclone(array<sector> s, vector2 first, vector2 second, weather_event it)
{
    if(time == 0)
    {
        attached_sectors.copy(s);
        god_of_weather = it;
        projection_x = first;
        projection_y = second;

        update_bbox_vertices(projection_x, projection_y);
        sector_thunderclouds();
        
        time = level.totaltime;

        vector2 sector_center = ( (projection_x.x + projection_x.y, projection_y.x + projection_y.y) / 2 );

        weather_sound = actor.spawn("thunder_and_lighting", pos:( sector_center , 0 )  );
    
        weather_sound.setorigin( (weather_sound.pos.xy, weather_sound.ceilingz), false);
    
        for (int i = 0; i < MAXPLAYERS; i++)
        {
            PlayerInfo p = players[i];
            
            if(playeringame[i] && p)
            {
                actor m = actor.spawn("rain_sound_speaker", pos:(sector_center, 0) );
                m.setorigin( (m.pos.xy, m.floorz), false);

                rain_sound_speaker(m).attach_to_player(p, self);
                rain_speakers_per_player.push(m);
            }
        }
    }
    return self;
}

bool sector_from_group(sector s)
{
    if(s)
    {
        for(uint i = 0; i < attached_sectors.size(); i++)
        {
            if(attached_sectors[i] && attached_sectors[i] == s )
            {
                return true;
                break;
            }
        }
    }
    return false;
}

//fill all sector gropu with weather spawn points
private void sector_thunderclouds()
{
    double p_dist = interval_between_points * 2;

    double x_length, y_length, x_delta, y_delta;
    int _x_, _y_;
    uint i = 0;

    x_length = projection_x.y - projection_x.y;
    y_length = projection_y.y - projection_y.y;

    x_delta = x_length / p_dist;
    y_delta = y_length / p_dist;
  
    _x_ = int(x_delta);
    _y_ = int(y_delta);

    if(abs(_x_) > 0)
        x_delta = abs( ( ( (x_delta - _x_) / _x_) * p_dist ) );
    if(abs(_y_) > 0)
        y_delta = abs( ( ( (y_delta - _y_) / _y_) * p_dist ) );

    x_delta += p_dist;
    y_delta += p_dist;

    double x_min = projection_x.x + interval_between_points;
    double y_min = projection_y.x + interval_between_points;

    for(double xx = x_min; xx < (projection_x.y + x_delta); xx += x_delta)
    {
        for(double yy = y_min; yy < (projection_y.y + y_delta); yy += y_delta)
        {
            thundercloud mp = thundercloud(new("thundercloud") ).condense_vapor( (xx, yy), self, (x_delta, y_delta) );
            if(mp)
                thunder_front.push(mp);
        }

        //precautionary measures
        i++;
        if(i > 10000000000)
            break;
    }
}

//technical method used in initialization inside event, return first attached sector
sector get_original_sector() const
{
    return attached_sectors[0];
}

//same as above, but return all attached sectors
void get_sectors(out array<sector> it) const
{
    it.copy(attached_sectors);
}

//obviou from name
vector2, vector2 get_sector_bounds() const
{
    return projection_x, projection_y;
}

uint return_state() const
{
    return cyclon_state;
}
protected void set_state(uint b)
{
    cyclon_state |= b;
}

//update bbox using new set of data
private void update_bbox_vertices(vector2 x_x, vector2 y_y)
{
    //order dont matter
    bounds_vertice_1 = (x_x.x, y_y.x);
    bounds_vertice_2 = (x_x.x, y_y.y);
    bounds_vertice_3 = (x_x.y, y_y.x);
    bounds_vertice_4 = (x_x.y, y_y.y);
    /*
    actor.spawn("armorbonus", pos:(bounds_vertice_1, 0) );
    actor.spawn("armorbonus", pos:(bounds_vertice_2, 0) );
    actor.spawn("armorbonus", pos:(bounds_vertice_3, 0) );
    actor.spawn("armorbonus", pos:(bounds_vertice_4, 0) );
    */
}

//technocal stuff for initialization, for merging two thinkers together
void merge_with(sector_cyclon with, weather_event caller)
{
    if(caller && with && caller.getclass() == "weather_event")
    {
        vector2 proj_x, proj_y;
        [proj_x, proj_y] = with.get_sector_bounds();

        with.get_sectors(attached_sectors);

        //again, because vectors arrys in zscript is just a dream 
        if(proj_x.x < projection_x.x)
            projection_x.x = proj_x.x;
        if(proj_x.y > projection_x.y)
            projection_x.y = proj_x.y;

        if(proj_y.x < projection_y.x)
            projection_y.x = proj_y.x;
        if(proj_y.y > projection_y.y)
            projection_y.y = proj_y.y;

        update_bbox_vertices(projection_x, projection_y);
    }
}


//МУЖЦИКИЙ ДОЖДЬ АЛЛИЛУЯ
weather_actor raining_men(vector3 v)
{
    if(god_of_weather)
    {
        weather_actor wa = weather_event(god_of_weather).find_droplet();

        switch(CWE_weather_type)
        {
            case CWE_SNOW:
                wa.setstatelabel("snow");
            break;

            case CWE_RAIN:
                wa.setstatelabel("rain");
            break;
            
            case CWE_ASHES:
                wa.setstatelabel("ashes");
            break;

            case CWE_WTF:
                wa.setstatelabel("god_what_it_is");
            break;

            default:
            break;
        }

        wa.setorigin(v, false);
    }
    return null;
}

//deconstructor
override void OnDestroy()
{
    for(uint i = 0; i < thunder_front.size(); i++)
        thunder_front[i].destroy();

    for(uint i = 0; i < rain_speakers_per_player.size(); i++)
        rain_speakers_per_player[i].destroy();
    
    super.ondestroy();
}

//next functions apply more specific effects on specific weather
private void check_for_ashes()
{
    if(CWE_weather_type == CWE_ASHES && !(cyclon_state & CSE_ASHED) )
    {
        cyclon_state |= CSE_ASHED;

        for(uint i = 0; i < attached_sectors.size(); i++)
        {
            attached_sectors[i].SetFade(color("C9C9C9") );
        }
    }

    if(CWE_weather_type != CWE_ASHES && (cyclon_state & CSE_ASHED) )
    {
        cyclon_state &= ~CSE_ASHED;

        for(uint i = 0; i < attached_sectors.size(); i++)
        {
            attached_sectors[i].SetFade(color("000000") );
        }
    }
}

private void check_for_snow()
{
    if(CWE_weather_type == CWE_SNOW && !(cyclon_state & CSE_SNOWY) )
    {
        cyclon_state |= CSE_SNOWY;

        for(uint i = 0; i < attached_sectors.size(); i++)
        {
            attached_sectors[i].SetFade(color("f0f0f0") );
        }
    }

    if(CWE_weather_type != CWE_SNOW && (cyclon_state & CSE_SNOWY) )
    {
        cyclon_state &= ~CSE_SNOWY;

        for(uint i = 0; i < attached_sectors.size(); i++)
        {
            attached_sectors[i].SetFade(color("000000") );
        }
    }
}

private void check_for_rain()
{
    if(CWE_weather_type == CWE_RAIN && !(cyclon_state & CSE_RAINY) )
    {
        cyclon_state |= CSE_RAINY;

        for(uint i = 0; i < attached_sectors.size(); i++)
        {
            attached_sectors[i].SetFade(color("b5b5ff") );
        }
    }

    if(CWE_weather_type != CWE_RAIN && (cyclon_state & CSE_RAINY) )
    {
        cyclon_state &= ~CSE_RAINY;

        for(uint i = 0; i < attached_sectors.size(); i++)
        {
            attached_sectors[i].SetFade(color("000000") );
        }
    }

    try_lighting();
}

//check is player near/inside sector group bbox
private bool inside_sector_bbox(actor a)
{
    if(!a)
        return false;

    double x_len, y_len;

    x_len = (projection_x.y - projection_x.x) / 2;
    y_len = (projection_y.y - projection_y.x) / 2;
       
    if( a.pos.x > projection_x.x - x_len &&
        a.pos.x < projection_x.y + x_len &&
        a.pos.y > projection_y.x - y_len &&
        a.pos.y < projection_y.y + y_len )
        return true; 

    return false;
}

//bright flash from lighting
private void lighting_bright_flash()
{
    for(int i = 0; i < MAXPLAYERS; i++)
    {
        PlayerInfo p = players[i];
        
       if(inside_sector_bbox(p.mo) )
       {
            p.mo.a_setblend("FF, FF, FF", 1, 10);
       }
    }
}

private void try_lighting()
{
    if(CWE_weather_type == CWE_RAIN)
    {
        if(random(0, 500) <= 1 && weather_sound) 
        {
            if(thunder_and_lighting(weather_sound).turn_on_lighting() )
                lighting_bright_flash();
        }
    }
}

//tic-tac, tic-tac, tic-tac.....
override void tick()
{
    if(!CWE_weather || globalfreeze) return;

    check_for_ashes();
    try_lighting();
}

}

//global enums for weather type
enum CWE_TYPE
{
    CWE_NONE = 0,//0
    CWE_SNOW = 1,//1
    CWE_RAIN = 1 << 1,//2
 
    CWE_ASHES = 1 <<2,//4
    CWE_WTF = 1 <<16//8
};

class base_weather_speaker : actor
{
default
{
    +nointeraction
    +noclip
    +nosector
}

}

//speaker class for thunder sound
class thunder_and_lighting : base_weather_speaker
{

override void MarkPrecacheSounds()
{
    //MarkSound("thunder_sound_random");
    MarkSound("thunder_sound_1");
    MarkSound("thunder_sound_2");
    MarkSound("thunder_sound_3");
    MarkSound("thunder_sound_4");
    MarkSound("thunder_sound_5");
    MarkSound("thunder_sound_6");
    MarkSound("thunder_sound_7");
    MarkSound("thunder_sound_8");

}

private uint timer, light_to_sound;
private bool lighting_time;

bool turn_on_lighting()
{
    if(timer <= 0)
    {
        lighting_time = true;
        timer = random (850, 3000);
        light_to_sound = random (15, 215);
        return true;
    }

    else return false;
}
states
{
    spawn:
        bon1 a 1 nodelay
        {
            //console.printf("timer %i light %i", timer, light_to_sound);
            if(timer > 0)
                timer --;

            if(light_to_sound > 0)
            {
                light_to_sound--;

                if( lighting_time == true && light_to_sound == 0)
                {
                    lighting_time = false;

                    //console.printf("thunder");
                    a_playsound("thunder_sound_random", CHAN_AUTO, 1);
                }
            }

            if(cwe_thunder_debug)
            {
                a_playsound("thunder_sound_random", CHAN_AUTO, 1);
                cvar.findcvar("cwe_thunder_debug").setint(0);
            }
        }
    loop;
}

}

class rain_sound_speaker : base_weather_speaker
{
private playerinfo player_target;
private sector_cyclon group_affiliation;
private textureid sky_texture;

void attach_to_player(playerinfo i, sector_cyclon g)
{
    player_target = i;
    group_affiliation = g;
    sky_texture = TexMan.checkForTexture("F_SKY1", TexMan.Type_Any);
}

override void MarkPrecacheSounds()
{
    MarkSound("rain_sound_random");
}

private vector3 almost_unit_vector(vector3 v)
{
    double divv = 0;
    if(abs(v.x) >= abs(v.y) && abs(v.x) >= abs(v.z) )
        divv = abs(v.x);
    if(abs(v.y) >= abs(v.x) && abs(v.y) >= abs(v.z) )
        divv = abs(v.y);
    if(abs(v.z) >= abs(v.y) && abs(v.z) >= abs(v.x) )
        divv = abs(v.z);

    v /= divv;

    return v;
}

private bool is_own_sector_group(sector s)
{
    if(group_affiliation)
    {
        return sector_cyclon(group_affiliation).sector_from_group(s);
    }
    return false;
}

states
{
    spawn:
        bon2 a 1 nodelay
        {
            //console.printf("pos %f %f %f", pos.x, pos.y, pos.z);
            if(!CWE_rain_sound)
            {
                console.printf("cvar false");
                return;
            }

            a_playsound("rain_sound_1", CHAN_BODY|CHAN_NOSTOP , 1);

            if(!player_target)
            {
                console.printf("no player");
                return;            
            }


            PlayerInfo p = player_target;

            vector3 move_dir = level.vec3diff(pos, p.camera.pos);
            if(p.camera.cursector.getTexture(Sector.ceiling) == sky_texture )
            {
                if(move_dir dot move_dir < 50 * 50 || is_own_sector_group(p.camera.cursector) )
                {
                    setorigin(p.camera.pos, false);
                    return;
                }
            }

            move_dir = almost_unit_vector(move_dir);

            move_dir *= 10;

            vector3 old_position = pos;

            setorigin(pos + move_dir, false);

            if(! (cursector.getTexture(Sector.ceiling) == TexMan.checkForTexture("F_SKY1", TexMan.Type_Any) ) )
            {
                setorigin(old_position, false);
            }
        }
    loop;
}

}